# -*- coding: utf-8 -*-
"""Copy of Web_UI.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/116ysbwRGIGc2u-hUHwKZQ6a_35DOCa8n
"""

!pip install -q ultralytics shapely opencv-python matplotlib geojson ifcopenshell tqdm pyngrok

import os
import cv2
import numpy as np
import matplotlib.pyplot as plt
from ultralytics import YOLO
from flask import Flask, request, jsonify
from shapely.geometry import Polygon, mapping
import geojson
import json
import ifcopenshell
# import ifcopenshell.api
import threading
from pyngrok import ngrok
from io import BytesIO
from google.colab import drive
from ultralytics import YOLO  # Assuming you're using the `ultralytics` YOLO library
from fastapi.responses import JSONResponse
import io
import base64
from PIL import Image
from fastapi.responses import StreamingResponse
OUTPUT_DIR = "output"
os.makedirs(OUTPUT_DIR, exist_ok=True)

ROOM_CLASSES = [
    'Bedroom', 'Dining Room', 'Foyer', 'Kitchen', 'Living Room',
    'Terrace', 'Terrace Lounge', 'attachBedroom', 'Balcony',
    'garage', 'lobby', 'study', 'toilet', 'utility', 'walkin'
]
OBJECT_CLASSES = [
    'Bed', 'Dining table', 'Sofa', 'Wardrobe', 'commode', 'door',
    'dress', 'duct', 'fridge', 'kitchen-slab', 'lift', 'sink',
    'stove', 'tv', 'wash', 'washing-machine', 'balcoa'
]
CLASS_THRESHOLDS = {
    'Bedroom': 0.5, 'Dining Room': 0.5, 'Foyer': 0.5, 'Kitchen': 0.5, 'Living Room': 0.5,
    'Terrace': 0.5, 'Terrace Lounge': 0.5, 'attachBedroom': 0.5, 'Balcony': 0.5, 'garage': 0.5,
    'lobby': 0.5, 'study': 0.5, 'toilet': 0.5, 'utility': 0.5, 'walkin': 0.5,
    'Bed': 0.7, 'Dining table': 0.65, 'Sofa': 0.65, 'Wardrobe': 0.65, 'commode': 0.4,
    'door': 0.65, 'dress': 0.5, 'duct': 0.5, 'fridge': 0.5, 'kitchen-slab': 0.5,
    'lift': 0.5, 'sink': 0.5, 'stove': 0.5, 'tv': 0.65, 'wash': 0.5, 'washing-machine': 0.5, 'balcoa': 0.5
}

def filter_boxes(boxes, masks, class_names, valid_classes, class_thresholds):
    keep = [
        i for i, (cls, conf) in enumerate(zip(boxes.cls, boxes.conf))
        if class_names[int(cls)] in valid_classes and conf > class_thresholds[class_names[int(cls)]]
    ]
    boxes.data = boxes.data[keep]
    if masks:
        masks.data = masks.data[keep]
    return boxes, masks

def save_filtered_mask(mask_result, path):
    if not mask_result[0].masks or not len(mask_result[0].masks.data):
        print(f"No valid masks for {path}")
        return
    height, width = mask_result[0].masks.data[0].shape
    combined_mask = np.zeros((height, width), dtype=np.uint8)
    for mask in mask_result[0].masks.data:
        binary_mask = (mask.cpu().numpy() > 0.5).astype(np.uint8) * 255
        combined_mask = np.maximum(combined_mask, binary_mask)
    kernel = np.ones((5, 5), np.uint8)
    cleaned_mask = cv2.morphologyEx(combined_mask, cv2.MORPH_CLOSE, kernel)
    cv2.imwrite(os.path.join(OUTPUT_DIR, path), cleaned_mask)

def overlay_mask(image, mask, color=(0, 255, 0), alpha=0.5):
    mask_resized = cv2.resize(mask, (image.shape[1], image.shape[0]))
    overlay = image.copy()
    colored_mask = np.zeros_like(image)
    colored_mask[mask_resized > 0] = color
    return cv2.addWeighted(colored_mask, alpha, image, 1 - alpha, 0)

def preprocess_mask(mask):
    _, binary = cv2.threshold(mask, 127, 255, cv2.THRESH_BINARY)
    kernel = np.ones((3, 3), np.uint8)
    clean = cv2.morphologyEx(binary, cv2.MORPH_OPEN, kernel)
    return clean

def safe_read_mask(path):
    mask = cv2.imread(path, cv2.IMREAD_GRAYSCALE)
    if mask is None:
        raise FileNotFoundError(f"Could not read: {path}")
    return mask

def mask_to_polygons(mask, min_area=100):
    if mask.ndim == 3:
        mask = cv2.cvtColor(mask, cv2.COLOR_RGB2GRAY)
    mask = mask.astype(np.uint8)
    mask[mask > 0] = 255
    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
    polygons = []
    for cnt in contours:
        if cv2.contourArea(cnt) >= min_area:
            coords = np.squeeze(cnt)
            if coords.ndim != 2 or coords.shape[0] < 4:
                continue
            poly = Polygon(coords)
            if poly.is_valid:
                polygons.append(poly)
    return polygons

from fastapi import FastAPI, File, UploadFile, HTTPException
from fastapi.responses import JSONResponse
import shutil
from fastapi.middleware.cors import CORSMiddleware
import os
import zipfile
drive.mount('/content/drive')
app = FastAPI()
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Or set specific origins like ["http://localhost:3000"]
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
OUTPUT_DIR = "output"
os.makedirs(OUTPUT_DIR, exist_ok=True)

@app.post("/process")
async def process_image(image: UploadFile = File(...)):
    if image.content_type not in ["image/jpeg", "image/png"]:
        raise HTTPException(status_code=400, detail="Invalid image format")

    image_path = os.path.join(OUTPUT_DIR, "uploaded_image.jpg")

    # Save the uploaded file to disk
    with open(image_path, "wb") as buffer:
        shutil.copyfileobj(image.file, buffer)

    # Step 2: Define paths to your model weights
    wall_model_path = "/content/drive/MyDrive/Trained_Model/wall_segmentor.pt"
    image_model_path = "/content/drive/MyDrive/Trained_Model/image_segmentor.pt"

    # Step 3: Load the models
    wall_model = YOLO(wall_model_path)
    image_model = YOLO(image_model_path)


    wall_result = wall_model(image_path, conf=0.5, iou=0.5)
    wall_img = wall_result[0].plot()
    wall_annot_path = os.path.join(OUTPUT_DIR, "wall_detection_annotated.jpg")
    cv2.imwrite(wall_annot_path, cv2.cvtColor(wall_img, cv2.COLOR_RGB2BGR))
    wall_detections = []
    for r in wall_result:
        boxes = r.boxes
        for box in boxes:
            wall_detections.append({
                "class_id": int(box.cls[0]),
                "confidence": float(box.conf[0]),
                "bbox": box.xyxy[0].tolist()  # [x1, y1, x2, y2]
            })
    room_result_raw = image_model(image_path, conf=0.3, iou=0.5)
    room_boxes, room_masks = room_result_raw[0].boxes, room_result_raw[0].masks
    room_names = image_model.names
    room_boxes, room_masks = filter_boxes(room_boxes, room_masks, room_names, ROOM_CLASSES, CLASS_THRESHOLDS)
    room_result_raw[0].boxes = room_boxes
    if room_masks:
        room_result_raw[0].masks.data = room_masks.data
    room_annot_path = os.path.join(OUTPUT_DIR, "room_detection_annotated.jpg")
    room_img = room_result_raw[0].plot()
    cv2.imwrite(room_annot_path, cv2.cvtColor(room_img, cv2.COLOR_RGB2BGR))

    object_result_raw = image_model(image_path, conf=0.3, iou=0.5)
    object_boxes, object_masks = object_result_raw[0].boxes, object_result_raw[0].masks
    object_names = image_model.names
    object_boxes, object_masks = filter_boxes(object_boxes, object_masks, object_names, OBJECT_CLASSES, CLASS_THRESHOLDS)
    object_result_raw[0].boxes = object_boxes
    if object_masks:
        object_result_raw[0].masks.data = object_masks.data
    object_annot_path = os.path.join(OUTPUT_DIR, "object_detection_annotated.jpg")
    object_img = object_result_raw[0].plot()
    cv2.imwrite(object_annot_path, cv2.cvtColor(object_img, cv2.COLOR_RGB2BGR))

    save_filtered_mask(wall_result, "walls.jpg")
    save_filtered_mask(room_result_raw, "rooms.jpg")
    save_filtered_mask(object_result_raw, "objects.jpg")

    original_img = cv2.cvtColor(cv2.imread(image_path), cv2.COLOR_BGR2RGB)
    wall_mask = cv2.imread(os.path.join(OUTPUT_DIR, "walls.jpg"), 0)
    room_mask = cv2.imread(os.path.join(OUTPUT_DIR, "rooms.jpg"), 0)
    object_mask = cv2.imread(os.path.join(OUTPUT_DIR, "objects.jpg"), 0)
    wall_overlay = overlay_mask(original_img, wall_mask, (255, 0, 0))
    room_overlay = overlay_mask(wall_overlay, room_mask, (0, 255, 0))
    final_overlay = overlay_mask(room_overlay, object_mask, (0, 0, 255))
    overlay_path = os.path.join(OUTPUT_DIR, "composite_overlay.jpg")
    cv2.imwrite(overlay_path, cv2.cvtColor(final_overlay, cv2.COLOR_RGB2BGR))

    mask_paths = [
        (os.path.join(OUTPUT_DIR, "objects.jpg"), "objects"),
        (os.path.join(OUTPUT_DIR, "rooms.jpg"), "rooms"),
        (os.path.join(OUTPUT_DIR, "walls.jpg"), "walls"),
    ]
    masks = {}
    for path, label in mask_paths:
        masks[label] = preprocess_mask(safe_read_mask(path))
    polygons = {}
    for label in masks:
        polygons[label] = mask_to_polygons(masks[label])
    all_polygons = []
    for label in polygons:
        for poly in polygons[label]:
            all_polygons.append({"label": label, "polygon": poly})
    features = [
        geojson.Feature(geometry=mapping(p["polygon"]), properties={"label": p["label"]})
        for p in all_polygons
    ]
    feature_collection = geojson.FeatureCollection(features)
    geojson_path = os.path.join(OUTPUT_DIR, "polygons_output.geojson")
    with open(geojson_path, "w") as f:
        geojson.dump(feature_collection, f, indent=2)

    ifc_path = os.path.join(OUTPUT_DIR, "floorplan_model.ifc")
    try:
        with open(geojson_path) as f:
            data = json.load(f)
        ifc = ifcopenshell.api.run("project.create_file")
        project = ifcopenshell.api.run("root.create_entity", ifc, ifc_class="IfcProject", name="Floorplan Project")
        ifcopenshell.api.run("unit.assign_unit", ifc, length={"is_metric": True, "raw": "METRE"})
        context = ifcopenshell.api.run("context.add_context", ifc, context_type="Model")
        body_context = ifcopenshell.api.run("context.add_context", ifc, context_type="Model", context_identifier="Body", target_view="MODEL_VIEW", parent=context)
        site = ifcopenshell.api.run("root.create_entity", ifc, ifc_class="IfcSite", name="Site")
        building = ifcopenshell.api.run("root.create_entity", ifc, ifc_class="IfcBuilding", name="Building")
        storey = ifcopenshell.api.run("root.create_entity", ifc, ifc_class="IfcBuildingStorey", name="Ground Floor")
        ifcopenshell.api.run("aggregate.assign_object", ifc, products=[site], relating_object=project)
        ifcopenshell.api.run("aggregate.assign_object", ifc, products=[building], relating_object=site)
        ifcopenshell.api.run("aggregate.assign_object", ifc, products=[storey], relating_object=building)
        HEIGHT_MAP = {
            "Bedroom": 0.2, "Living Room": 0.2, "Kitchen": 2, "Bathroom": 0.2, "Terrace": 2, "Balcony": 2,
            "Wall": 3, "Door": 1, "Window": 1.2, "Wardrobe": 1, "Bed": 0.4, "commode": 0.3, "default": 3.0
        }
        all_coords = []
        for feature in data["features"]:
            coords = feature["geometry"]["coordinates"][0]
            all_coords.extend(coords)
        if not all_coords:
            raise Exception("No polygons found.")
        global_xs = [c[0] for c in all_coords]
        global_ys = [c[1] for c in all_coords]
        global_minx, global_maxx = min(global_xs), max(global_xs)
        global_miny, global_maxy = min(global_ys), max(global_ys)
        global_centerx = (global_minx + global_maxx) / 2
        global_centery = (global_miny + global_maxy) / 2
        scale = 0.01
        def get_room_height(label):
            if label in HEIGHT_MAP:
                return HEIGHT_MAP[label]
            label_lower = label.lower()
            for room_type, height in HEIGHT_MAP.items():
                if room_type.lower() in label_lower:
                    return height
            return HEIGHT_MAP["default"]
        def create_room_from_polygon(ifc, context, coords, label, height, global_offset):
            scaled_coords = [((x - global_offset[0]) * scale, (y - global_offset[1]) * scale) for x, y in coords[:-1]]
            points = [ifc.createIfcCartesianPoint([float(x), float(y), 0.0]) for x, y in scaled_coords]
            polyline = ifc.createIfcPolyLine(points)
            profile = ifc.createIfcArbitraryClosedProfileDef("AREA", None, polyline)
            placement = ifc.createIfcAxis2Placement3D(
                ifc.createIfcCartesianPoint([0.0, 0.0, 0.0]),
                ifc.createIfcDirection([0.0, 0.0, 1.0]),
                ifc.createIfcDirection([1.0, 0.0, 0.0])
            )
            extrusion_direction = ifc.createIfcDirection([0.0, 0.0, 1.0])
            solid = ifc.createIfcExtrudedAreaSolid(profile, placement, extrusion_direction, float(height))
            body_rep = ifc.createIfcShapeRepresentation(body_context, "Body", "SweptSolid", [solid])
            product_shape = ifc.createIfcProductDefinitionShape(None, None, [body_rep])
            if height > 2.5:
                element = ifc.createIfcSlab(ifcopenshell.guid.new(), None, label, None, None, None, None, None)
            elif height < 1.5:
                element = ifc.createIfcBuildingElementProxy(ifcopenshell.guid.new(), None, label, None, None, None, None, None)
            else:
                element = ifc.createIfcWall(ifcopenshell.guid.new(), None, label, None, None, None, None, None)
            element.Representation = product_shape
            element.ObjectPlacement = ifc.createIfcLocalPlacement(
                storey.ObjectPlacement,
                ifc.createIfcAxis2Placement3D(
                    ifc.createIfcCartesianPoint([0.0, 0.0, 0.0]),
                    ifc.createIfcDirection([0.0, 0.0, 1.0]),
                    ifc.createIfcDirection([1.0, 0.0, 0.0])
                )
            )
            return element, height
        room_count = 0
        global_offset = (global_centerx, global_centery)
        for feature in data["features"]:
            label = feature["properties"].get("label", "Unnamed")
            coords = feature["geometry"]["coordinates"][0]
            try:
                poly = Polygon(coords)
                if not poly.is_valid or poly.area < 1.0:
                    continue
                room_height = get_room_height(label)
                room, actual_height = create_room_from_polygon(ifc, body_context, coords, label, room_height, global_offset)
                ifcopenshell.api.run("spatial.assign_container", ifc, products=[room], relating_structure=storey)
                room_count += 1
            except Exception as e:
                print(f"Failed: {label} - {str(e)}")
        ifc.write(ifc_path)
    except Exception as e:
        ifc_path = ""
        print(f"IFC export failed: {e}")

    # response = {
    #     "status": "success",
    #     "wall_annotated": wall_annot_path,
    #     "room_annotated": room_annot_path,
    #     "object_annotated": object_annot_path,
    #     "overlay": overlay_path,
    #     "geojson": geojson_path,
    #     "ifc": ifc_path
    # }
    zip_bytes = BytesIO()
    with zipfile.ZipFile(zip_bytes, 'w', zipfile.ZIP_DEFLATED) as zipf:
        zipf.write(wall_annot_path, arcname="wall_detection_annotated.jpg")
        zipf.write(room_annot_path, arcname="room_detection_annotated.jpg")
        zipf.write(object_annot_path, arcname="object_detection_annotated.jpg")
        zipf.write(overlay_path, arcname="composite_overlay.jpg")
        zipf.write(geojson_path, arcname="polygons_output.geojson")
        zipf.write(ifc_path, arcname="floorplan_model.ifc")
    zip_bytes.seek(0)

    return StreamingResponse(
        zip_bytes,
        media_type="application/x-zip-compressed",
        headers={"Content-Disposition": "attachment; filename=structify_output.zip"}
    )

import uvicorn
from pyngrok import ngrok
import nest_asyncio
!ngrok authtoken 2zESaoP7W8ztZ2dApfVNgyIGawV_6uEns7U4d35KaDqfxstLz
# Allow async in Colab
nest_asyncio.apply()
# Start ngrok tunnel
public_url = ngrok.connect(8000)
print("Public URL:", public_url)

# Run FastAPI server
uvicorn.run(app, host="0.0.0.0", port=8000)

